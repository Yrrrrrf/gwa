# GWA Docker Compose with Traefik

# Define common environment variables
x-common-env: &common-env
  DB_NAME: ${DB_NAME:-gwa}
  DB_OWNER_ADMIN: ${DB_OWNER_ADMIN:-gwa_owner}
  DB_OWNER_PWORD: ${DB_OWNER_PWORD:-password}

services:
  # * Traefik reverse proxy service
  # ^ Handles HTTPS termination, SSL certificates, and routing to services
  traefik:
    image: traefik:v3.5.4
    container_name: gwa-traefik
    command:
      # * Enable Docker provider with exposedByDefault=false for security
      # ^ Traefik will only route services that have specific labels
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      # * Use the configuration file we created
      - --configFile=/etc/traefik/traefik.yml
      # * Enable dashboard access for monitoring
      # ^ Access at http://localhost:8080 when insecure mode is enabled
      # - --api.insecure=true
      - --api.dashboard=true
    ports:
      # * HTTP entry point - redirects to HTTPS
      - "8080:80"
      # * HTTPS entry point - main service entry
      - "8443:443"
    volumes:
      # * Mount Docker/Podman socket for service discovery
      # ^ For root Podman: /var/run/docker.sock (same as Docker)
      # ^ For rootless Podman: typically $XDG_RUNTIME_DIR/podman/podman.sock
      # ^ Uncomment the appropriate line below for your setup:
      # - /var/run/docker.sock:/var/run/docker.sock:ro  # * For Docker or root Podman
      - ${XDG_RUNTIME_DIR}/podman/podman.sock:/var/run/docker.sock:ro  # * For rootless Podman (uncomment if needed)
      # * Mount our Traefik configuration file
      - ./traefik.yml:/etc/traefik/traefik.yml:ro
      # * Mount volume for storing certificates
      - traefik-certs:/etc/traefik/acme.json
    networks:
      - gwa-network
    labels:
      # * Route traffic to Traefik dashboard
      # ^ Only accessible through the configured domain
      - traefik.enable=true
      - traefik.http.routers.dashboard.rule=Host(`traefik.localhost`)  # * Change this to your domain
      - traefik.http.routers.dashboard.service=api@internal
      - traefik.http.routers.dashboard.entrypoints=https
      - traefik.http.routers.dashboard.tls=true
      # - traefik.http.routers.dashboard.tls.certresolver=letsencrypt  # Comment out for dev
      # - traefik.http.routers.dashboard.middlewares=auth # Commented out for dev
      # * Enable basic authentication for dashboard
      # ^ Generate with: htpasswd -nb username password
      # ^ Replace with your own encrypted credentials in production
      # - traefik.http.middlewares.auth.basicauth.users=admin:$$apr1$$11z26...$$7QJgP4oY6YF2X0.jeJw9r/  # * Example only - change this!
    depends_on:
      - db

  db:
    build:
      context: ./server/db/
      dockerfile: db.Dockerfile
    container_name: gwa-db
    environment:
      <<: *common-env # Include all common variables
      # PostgreSQL-specific variables
      POSTGRES_DB: ${DB_NAME:-gwa}
      POSTGRES_USER: ${DB_OWNER_ADMIN:-gwa_owner}
      POSTGRES_PASSWORD: ${DB_OWNER_PWORD:-password}
      TZ: UTC
    # * Removed direct port exposure - now accessible via internal network only
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - gwa-network
    healthcheck:
      test: [
        "CMD-SHELL",
        "pg_isready -U ${DB_OWNER_ADMIN:-gwa_owner} -d ${DB_NAME:-gwa}",
      ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  api:
    build:
      context: ./server/api/
      dockerfile: api.Dockerfile
    container_name: gwa-api
    environment:
      <<: *common-env
      DB_HOST: gwa-db
      PYTHONDONTWRITEBYTECODE: 1
      PYTHONUNBUFFERED: 1
    volumes:
      - ./server/api/src:/app/src:ro
    depends_on:
      db:
        condition: service_healthy
    networks:
      - gwa-network
    # --- VERIFY THIS SECTION CAREFULLY ---
    labels:
      # Enable Traefik for this service
      - traefik.enable=true

      # Define the router for the API
      - traefik.http.routers.api.rule=Host(`api.localhost`)
      - traefik.http.routers.api.entrypoints=https
      
      # Enable TLS for this router
      - traefik.http.routers.api.tls=true
      
      # Define the service and its port
      - traefik.http.services.api.loadbalancer.server.port=8000
    healthcheck:
      test: ["CMD", "curl", "-f", "http://0.0.0.0:8000/health"]
      interval: 10s # Reduced from 30s
      timeout: 5s # Reduced from 10s
      retries: 5 # Increased from 3
      start_period: 5s # Reduced from 10s

  app:
    build:
      context: ./client  # Sets build context to client directory
      dockerfile: app.Dockerfile
    container_name: gwa-app
    # * Removed direct port exposure - now accessible via labels and Traefik routing
    depends_on:
      - db
      - api
    networks:
      - gwa-network
    # * Traefik labels for routing traffic to this service
    # ^ These labels tell Traefik how to route traffic to the web app service
    labels:
      # * Enable Traefik routing for this service
      - traefik.enable=true
      # * Define the router for the web app service
      - traefik.http.routers.app.rule=Host(`app.localhost`)  # * Changed to app.localhost for consistency
      - traefik.http.routers.app.entrypoints=https
      # * Enable TLS with self-signed certificates for development
      - traefik.http.routers.app.tls=true
      # - traefik.http.routers.app.tls.certresolver=letsencrypt  # Comment out for dev
      # * Define the service and target port (Vite runs on 5173)
      - traefik.http.services.app.loadbalancer.server.port=5173

networks:
  gwa-network:
    name: gwa-network
    driver: bridge

volumes:
  postgres_data:
    name: gwa-postgres-data
  # * Volume for storing Let's Encrypt certificates
  # ^ This ensures certificates persist across container restarts
  traefik-certs:
    name: gwa-traefik-certs
